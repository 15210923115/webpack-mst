* 最影响用户体验的是网页首次打开时的加载等待。 导致这个问题的根本是网络传输过程耗时大，CDN的作用就是加速网络传输。
* CDN 又叫内容分发网络，通过把资源部署到世界各地，用户在访问时按照就近原则从离用户最近的服务器获取资源，从而加速资源的获取速度
* 用户使用浏览器第一次访问我们的站点时，该页面引入了各式各样的静态资源，如果我们能做到持久化缓存的话，可以在 http 响应头加上 Cache-control 或 Expires 字段来设置缓存，浏览器可以将这些资源一一缓存到本地
* 用户在后续访问的时候，如果需要再次请求同样的静态资源，且静态资源没有过期，那么浏览器可以直接走本地缓存而不用再通过网络请求资源
* 缓存配置
  * HTML文件不缓存，放在自己的服务器上，关闭自己服务器的缓存，静态资源的URL变成指向CDN服务器的地址
  * 静态的JavaScript、CSS、图片等文件开启CDN和缓存，并且文件名带上HASH值
  * 为了并行加载不阻塞，把不同的静态资源分配到不同的CDN服务器上
* 域名限制
  * 同一时刻针对同一个域名的资源并行请求是有限制
  * 可以把这些静态资源分散到不同的 CDN 服务上去
  * 多个域名后会增加域名解析时间
  * 可以通过在 HTML HEAD 标签中 加入去预解析域名，以降低域名解析带来的延迟

我们的首页，也就是html页面，一般是不缓存的。像我们的第三方库是强缓存的。

`为什么index.html不用缓存？`因为访问的时候，是直接http://xx.xx.com/xx/index.html这样访问的，index.html文件名里不带hash值，如果设置了强缓存，那么等到下次发版更新了index.html里的内容，客户端浏览器访问到的还是上次缓存好的index.html，因此得不到更新。`为什么第三方库可以强缓存？`因为第三方库，都是我们在index.html文件里使用的时候引入的，每次webpack打包的时候，都会带上hash值，因此它是可以在客户端得到更新的。

* hash就是文件的指纹，就是打包后输出的文件名和后缀。
* hash一般是结合CDN缓存来使用，通过webpack构建之后，生成对应文件名自动带上对应的MD5值。如果文件内容改变的话，那么对应文件哈希值也会改变，对应的HTML引用的URL地址也会改变，触发CDN服务器从源服务器上拉取对应数据，进而更新本地缓存。

如果要合理使用缓存，首先要在文件名里加上hash值，见如下的webpack配置：
```js
{
    output: {
        path: path.resolve(__dirname, "dist"),
        filename: "[name].[hash].js",
        chunkFilename: "[name].[hash].chunk.js"
    },
    plugins: [
        new MiniCssExtractPlugin([
            filename: "[name].[hash].css"
        ])
    ]
}
```
加载文件的时候，通过hash值来判断文件是否更新了，如果更新了，就请求新的文件，如果没更新，就使用缓存的文件。

如何设置强缓存？    
答：在http响应头加上Cache-control或Expires字段来设置缓存，浏览器可以将这些资源一一缓存到本地。

CDN我们一般使用一些云服务厂商提供的CDN服务。我们需要将编译后的文件，上传到CDN服务器上。

<font color=cyan>如何将编译后的文件上传到CDN服务器？</font>可以看`9.optimize/webpack.config.js`里的`new UploadPlugin({})`，`UploadPlugin`插件是专门用来将webpack编译后产出的文件上传到CDN服务器的。

在部署的时候，前端打包还是需要使用webpack进行打包的，也就是npm run build。所以，会在线上部署的时候，进行CDN上传服务。